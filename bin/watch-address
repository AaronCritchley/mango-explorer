#!/usr/bin/env pyston3

import argparse
import logging
import os
import os.path
import rx
import rx.operators
import sys
import threading

from decimal import Decimal
from solana.publickey import PublicKey

sys.path.insert(0, os.path.abspath(
    os.path.join(os.path.dirname(__file__), "..")))
import mango  # nopep8
import mango.layouts  # nopep8
import mango.marketmaking.fixedratiosdesiredordersbuilder  # nopep8
import mango.marketmaking.marketmaker  # nopep8
import mango.marketmaking.modelstate  # nopep8
import mango.marketmaking.toleranceorderreconciler  # nopep8

parser = argparse.ArgumentParser(description="Shows the on-chain data of a particular account.")
mango.Context.add_command_line_parameters(parser)
mango.Wallet.add_command_line_parameters(parser)
parser.add_argument("--address", type=PublicKey, required=True, help="Address of the Solana account to watch")
parser.add_argument("--account-type", type=str, required=True,
                    help="Underlying object type of the data in the AccountInfo")
args = parser.parse_args()

logging.getLogger().setLevel(args.log_level)
logging.warning(mango.WARNING_DISCLAIMER_TEXT)

context = mango.Context.from_command_line_parameters(args)

disposer = mango.DisposePropagator()
manager = mango.WebSocketSubscriptionManager()
disposer.add_disposable(manager)


def build_converter(context: mango.Context, account_type):
    account_type_upper = account_type.upper()
    if account_type_upper == "ACCOUNTINFO":
        return lambda account_info: account_info
    elif account_type_upper == "GROUP":
        return lambda account_info: mango.Group.parse(context, account_info)
    elif account_type_upper == "ACCOUNT":
        account_info = mango.AccountInfo.load(context, args.address)
        if account_info is None:
            raise Exception(f"No account at {args.address}.")
        layout_account = mango.layouts.MANGO_ACCOUNT.parse(account_info.data)
        group_address = layout_account.group
        group: mango.Group = mango.Group.load(context, group_address)
        return lambda account_info: mango.Account.parse(context, account_info, group)
    elif account_type_upper == "OPENORDERS":
        return lambda account_info: mango.OpenOrders.parse(account_info, Decimal(6), Decimal(6))
    elif account_type_upper == "PERPEVENTQUEUE":
        return lambda account_info: mango.PerpEventQueue.parse(account_info)
    elif account_type_upper == "PERPEVENTS":
        class EventSplitter:
            def __init__(self):
                self.seq_num = Decimal(0)

            def split(self, item: mango.PerpEventQueue) -> None:
                events = item.events[int(self.seq_num):int(item.sequence_number)]
                self.seq_num = item.sequence_number
                return events

        splitter: EventSplitter = EventSplitter()

        def _split_events(account_info: mango.AccountInfo):
            perp_event_queue = mango.PerpEventQueue.parse(account_info)
            return splitter.split(perp_event_queue)

        return _split_events
    raise Exception(f"Could not find AccountInfo converter for type {account_type}.")


subscription = mango.WebSocketSubscription[mango.AccountInfo](
    context, args.address, lambda account_info: account_info)
manager.add(subscription)

subscription.publisher.pipe(
    rx.operators.flat_map(build_converter(context, args.account_type))
).subscribe(mango.PrintingObserverSubscriber(False))

websocket_url = context.cluster_url.replace("https", "ws", 1)
ws: mango.ReconnectingWebsocket = mango.ReconnectingWebsocket(websocket_url, manager.open_handler, manager.on_item)
ws.ping_interval = 10
ws.open()

# Wait - don't exit. Exiting will be handled by signals/interrupts.
waiter = threading.Event()
try:
    waiter.wait()
except:
    pass

logging.info("Shutting down...")
ws.close()
disposer.dispose()
logging.info("Shutdown complete.")
